using k8s.Models;
using TrivyOperator.Dashboard.Application.Services.BackgroundQueues;
using TrivyOperator.Dashboard.Application.Services.CacherRefresh.Abstractions;
using TrivyOperator.Dashboard.Application.Services.WatcherEvents;
using TrivyOperator.Dashboard.Application.Services.WatcherParams;
using TrivyOperator.Dashboard.Domain.Trivy.VulnerabilityReport;
using TrivyOperator.Dashboard.Infrastructure.Abstractions;

namespace TrivyOperator.Dashboard.Application.Services.CacherRefresh;

public class KubernetesVulnerabilityReportCacheRefresh : CacheRefresh<VulnerabilityReportCR, KubernetesVulnerabilityReportWatcherEvent, KubernetesVulnerabilityReportBackgroundQueue>
{
    public KubernetesVulnerabilityReportCacheRefresh(KubernetesVulnerabilityReportBackgroundQueue backgroundQueue,
        IConcurrentCache<string, List<VulnerabilityReportCR>> cache,
        ILogger<CacheRefresh<VulnerabilityReportCR, KubernetesVulnerabilityReportWatcherEvent, KubernetesVulnerabilityReportBackgroundQueue>> logger) 
        : base(backgroundQueue, cache, logger)
    { }

    protected override void ProcessAddEvent(KubernetesVulnerabilityReportWatcherEvent watcherEvent, CancellationToken cancellationToken)
    {
        string eventNamespaceName = watcherEvent.KubernetesObject.Metadata.Namespace();
        string eventKubernetesObjectName = watcherEvent.KubernetesObject.Metadata.Name;

        if (cache.TryGetValue(eventNamespaceName, value: out List<VulnerabilityReportCR>? kubernetesNamespaces))
        {
            // TODO try catch - clear duplicates
            VulnerabilityReportCR potentialExistingKubernetesObject = kubernetesNamespaces.SingleOrDefault(x => x.Metadata.Name == eventKubernetesObjectName) ?? null;
            if (potentialExistingKubernetesObject is not null)
            {
                kubernetesNamespaces.Remove(potentialExistingKubernetesObject);
            }
            kubernetesNamespaces.Add(watcherEvent.KubernetesObject);
        }
        else // first time, the cache is really empty
        {
            cache.TryAdd(eventNamespaceName, new() { watcherEvent.KubernetesObject });
        }
    }

    protected override void ProcessDeleteEvent(KubernetesVulnerabilityReportWatcherEvent watcherEvent)
    {
        string eventNamespaceName = watcherEvent.KubernetesObject.Metadata.Namespace();
        string eventKubernetesObjectName = watcherEvent.KubernetesObject.Metadata.Name;

        if (cache.TryGetValue(eventNamespaceName, value: out List<VulnerabilityReportCR>? kubernetesNamespaces))
        {
            // TODO try catch - clear duplicates
            VulnerabilityReportCR toBedeletedKubernetesObject = kubernetesNamespaces.SingleOrDefault(x => x.Metadata.Name == eventKubernetesObjectName) ?? null;
            if (toBedeletedKubernetesObject is not null)
            {
                kubernetesNamespaces.Remove(toBedeletedKubernetesObject);
            }
        }
    }

    protected override void ProcessErrorEvent(KubernetesVulnerabilityReportWatcherEvent watcherEvent)
    {
        cache.TryRemove(watcherEvent.KubernetesObject.Namespace(), out _);
        cache.TryAdd(watcherEvent.KubernetesObject.Namespace(), new());
    }
}
